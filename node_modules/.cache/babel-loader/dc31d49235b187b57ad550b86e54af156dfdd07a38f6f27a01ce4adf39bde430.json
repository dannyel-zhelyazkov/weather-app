{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { forecastService } from '../../api';\nimport { convertToMonthDay, parseForecastObject } from '../../utils';\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from '../../common/constants';\nimport moment from 'moment';\nconst initialState = {\n  forecast: {},\n  currentWeathers: [],\n  isForecastLoading: undefined\n};\nexport const forecastSlice = createSlice({\n  name: 'forecast',\n  initialState,\n  reducers: {\n    setForecast: (state, action) => {\n      var _action$payload;\n      state.forecast = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.list.reduce((acc, current) => {\n        const key = convertToMonthDay(current.dt_txt);\n        const weatherObj = parseForecastObject(current);\n        if (!acc[key]) {\n          acc[key] = [weatherObj];\n          return acc;\n        }\n        acc[key].push(weatherObj);\n        return acc;\n      }, {});\n    },\n    setCurrentWeathers: state => {\n      state.currentWeathers = Object.entries(state.forecast).splice(1, 4).map(entry => ({\n        ...entry[1][Math.floor(moment().hour() / 3)] // Current hour divided by 3 will give the index of the current hour's forecast\n      }));\n    },\n\n    setIsForecastLoading: (state, action) => {\n      state.isForecastLoading = action.payload;\n    }\n  }\n});\nexport const fetchForecast = () => dispatch => {\n  try {\n    dispatch(setIsForecastLoading(true));\n    navigator.geolocation.getCurrentPosition(async position => {\n      const lat = position.coords.latitude;\n      const lon = position.coords.longitude;\n      const units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n      const response = await forecastService().getForecast({\n        lat,\n        lon,\n        units\n      });\n      dispatch(setIsForecastLoading(false));\n      dispatch(setForecast(response));\n    });\n  } catch (e) {\n    dispatch(setIsForecastLoading(false));\n  }\n};\nexport const {\n  setForecast,\n  setCurrentWeathers,\n  setIsForecastLoading\n} = forecastSlice.actions;\nexport const forecastReducer = forecastSlice.reducer;","map":{"version":3,"names":["createSlice","forecastService","convertToMonthDay","parseForecastObject","STANDARD_UNIT","WEATHER_METRIC_KEY","moment","initialState","forecast","currentWeathers","isForecastLoading","undefined","forecastSlice","name","reducers","setForecast","state","action","_action$payload","payload","list","reduce","acc","current","key","dt_txt","weatherObj","push","setCurrentWeathers","Object","entries","splice","map","entry","Math","floor","hour","setIsForecastLoading","fetchForecast","dispatch","navigator","geolocation","getCurrentPosition","position","lat","coords","latitude","lon","longitude","units","localStorage","getItem","response","getForecast","e","actions","forecastReducer","reducer"],"sources":["/Users/maistor_dany/Projects/weather-app/src/store/forecast/forecast.slice.ts"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\nimport { AppDispatch } from '../index';\nimport { forecastService } from '../../api';\nimport { HourlyForecastDisplay } from '../types';\nimport { convertToMonthDay, parseForecastObject } from '../../utils';\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from '../../common/constants';\nimport { ForecastData } from '../../api/types';\nimport moment from 'moment';\n\ntype ForecastState = {\n\tforecast: { [key: string]: HourlyForecastDisplay[] };\n\tcurrentWeathers: HourlyForecastDisplay[];\n\tisForecastLoading?: boolean;\n};\n\nconst initialState: ForecastState = {\n\tforecast: {},\n\tcurrentWeathers: [],\n\tisForecastLoading: undefined,\n};\n\nexport const forecastSlice = createSlice({\n\tname: 'forecast',\n\tinitialState,\n\treducers: {\n\t\tsetForecast: (state, action) => {\n\t\t\tstate.forecast = action.payload?.list.reduce(\n\t\t\t\t(\n\t\t\t\t\tacc: { [key: string]: HourlyForecastDisplay[] },\n\t\t\t\t\tcurrent: ForecastData\n\t\t\t\t) => {\n\t\t\t\t\tconst key = convertToMonthDay(current.dt_txt);\n\t\t\t\t\tconst weatherObj = parseForecastObject(current);\n\n\t\t\t\t\tif (!acc[key]) {\n\t\t\t\t\t\tacc[key] = [weatherObj];\n\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\tacc[key].push(weatherObj);\n\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{}\n\t\t\t);\n\t\t},\n\t\tsetCurrentWeathers: (state) => {\n\t\t\tstate.currentWeathers = Object.entries(state.forecast)\n\t\t\t\t.splice(1, 4)\n\t\t\t\t.map((entry: [string, any]) => ({\n\t\t\t\t\t...entry[1][Math.floor(moment().hour() / 3)], // Current hour divided by 3 will give the index of the current hour's forecast\n\t\t\t\t}));\n\t\t},\n\t\tsetIsForecastLoading: (state, action) => {\n\t\t\tstate.isForecastLoading = action.payload;\n\t\t},\n\t},\n});\n\nexport const fetchForecast = () => (dispatch: AppDispatch) => {\n\ttry {\n\t\tdispatch(setIsForecastLoading(true));\n\t\tnavigator.geolocation.getCurrentPosition(async (position) => {\n\t\t\tconst lat = position.coords.latitude;\n\t\t\tconst lon = position.coords.longitude;\n\n\t\t\tconst units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n\t\t\tconst response = await forecastService().getForecast({\n\t\t\t\tlat,\n\t\t\t\tlon,\n\t\t\t\tunits,\n\t\t\t});\n\n\t\t\tdispatch(setIsForecastLoading(false));\n\t\t\tdispatch(setForecast(response));\n\t\t});\n\t} catch (e) {\n\t\tdispatch(setIsForecastLoading(false));\n\t}\n};\n\nexport const { setForecast, setCurrentWeathers, setIsForecastLoading } =\n\tforecastSlice.actions;\n\nexport const forecastReducer = forecastSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}