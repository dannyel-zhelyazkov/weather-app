{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { forecastService } from \"../../api\";\nimport { convertToMonthDay, parseForecastObject } from \"../../utils\";\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from \"../../common/constants\";\nimport moment from \"moment\";\nconst initialState = {\n  forecast: {},\n  isForecastLoading: undefined\n};\nexport const forecastSlice = createSlice({\n  name: \"forecast\",\n  initialState,\n  reducers: {\n    setForecast: (state, action) => {\n      var _action$payload;\n      state.forecast = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.list.reduce((acc, current) => {\n        const key = convertToMonthDay(current.dt_txt);\n        const weatherObj = parseForecastObject(current);\n        if (!acc[key]) {\n          acc[key] = [weatherObj];\n          return acc;\n        }\n        acc[key].push(weatherObj);\n        return acc;\n      }, {});\n    },\n    setIsForecastLoading: (state, action) => {\n      state.isForecastLoading = action.payload;\n    }\n  }\n});\nexport const fetchForecast = () => dispatch => {\n  try {\n    dispatch(setIsForecastLoading(true));\n    navigator.geolocation.getCurrentPosition(async position => {\n      const lat = position.coords.latitude;\n      const lon = position.coords.longitude;\n      const units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n      const response = await forecastService().getForecast({\n        lat,\n        lon,\n        units\n      });\n      dispatch(setIsForecastLoading(false));\n      dispatch(setForecast(response));\n    });\n  } catch (e) {\n    dispatch(setIsForecastLoading(false));\n  }\n};\nexport const {\n  setForecast,\n  setIsForecastLoading\n} = forecastSlice.actions;\nexport const forecastReducer = forecastSlice.reducer;\nexport const selectNextFourDaysWeather = state => Object.entries(state.forecast).splice(1, 4).map(entry => ({\n  ...entry[1][Math.floor(moment().hour() / 3)] // Current hour divided by 3 will give the index of the current hour's forecast\n}));","map":{"version":3,"names":["createSlice","forecastService","convertToMonthDay","parseForecastObject","STANDARD_UNIT","WEATHER_METRIC_KEY","moment","initialState","forecast","isForecastLoading","undefined","forecastSlice","name","reducers","setForecast","state","action","_action$payload","payload","list","reduce","acc","current","key","dt_txt","weatherObj","push","setIsForecastLoading","fetchForecast","dispatch","navigator","geolocation","getCurrentPosition","position","lat","coords","latitude","lon","longitude","units","localStorage","getItem","response","getForecast","e","actions","forecastReducer","reducer","selectNextFourDaysWeather","Object","entries","splice","map","entry","Math","floor","hour"],"sources":["/Users/maistor_dany/Projects/weather-app/src/store/forecast/forecast.slice.ts"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\nimport { AppDispatch, ForecastDisplay, RootState } from \"../index\";\nimport { forecastService } from \"../../api\";\nimport { convertToMonthDay, parseForecastObject } from \"../../utils\";\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from \"../../common/constants\";\nimport moment from \"moment\";\nimport { ForecastData } from \"../../api/types\";\n\ntype ForecastState = {\n  forecast: ForecastDisplay;\n  isForecastLoading?: boolean;\n};\n\nconst initialState: ForecastState = {\n  forecast: {},\n  isForecastLoading: undefined,\n};\n\nexport const forecastSlice = createSlice({\n  name: \"forecast\",\n  initialState,\n  reducers: {\n    setForecast: (state, action) => {\n      state.forecast = action.payload?.list.reduce(\n        (acc: ForecastDisplay, current: ForecastData) => {\n          const key = convertToMonthDay(current.dt_txt);\n          const weatherObj = parseForecastObject(current);\n\n          if (!acc[key]) {\n            acc[key] = [weatherObj];\n\n            return acc;\n          }\n\n          acc[key].push(weatherObj);\n\n          return acc;\n        },\n        {},\n      );\n    },\n    setIsForecastLoading: (state, action) => {\n      state.isForecastLoading = action.payload;\n    },\n  },\n});\n\nexport const fetchForecast = () => (dispatch: AppDispatch) => {\n  try {\n    dispatch(setIsForecastLoading(true));\n    navigator.geolocation.getCurrentPosition(async (position) => {\n      const lat = position.coords.latitude;\n      const lon = position.coords.longitude;\n\n      const units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n      const response = await forecastService().getForecast({\n        lat,\n        lon,\n        units,\n      });\n\n      dispatch(setIsForecastLoading(false));\n      dispatch(setForecast(response));\n    });\n  } catch (e) {\n    dispatch(setIsForecastLoading(false));\n  }\n};\n\nexport const { setForecast, setIsForecastLoading } = forecastSlice.actions;\n\nexport const forecastReducer = forecastSlice.reducer;\n\nexport const selectNextFourDaysWeather = (state: RootState) =>\n  Object.entries(state.forecast)\n    .splice(1, 4)\n    .map((entry: [string, any]) => ({\n      ...entry[1][Math.floor(moment().hour() / 3)], // Current hour divided by 3 will give the index of the current hour's forecast\n    }));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}