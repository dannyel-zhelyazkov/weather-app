{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { forecastService } from \"../../api\";\nimport { convertToMonthDay, parseForecastObject } from \"../../utils\";\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from \"../../common/constants\";\nimport moment from \"moment\";\nconst initialState = {\n  forecast: {},\n  currentWeathers: [],\n  isForecastLoading: undefined\n};\nexport const forecastSlice = createSlice({\n  name: \"forecast\",\n  initialState,\n  reducers: {\n    setForecast: (state, action) => {\n      var _action$payload;\n      state.forecast = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.list.reduce((acc, current) => {\n        const key = convertToMonthDay(current.dt_txt);\n        const weatherObj = parseForecastObject(current);\n        if (!acc[key]) {\n          acc[key] = [weatherObj];\n          return acc;\n        }\n        acc[key].push(weatherObj);\n        return acc;\n      }, {});\n    },\n    setCurrentWeathers: state => {\n      state.currentWeathers = Object.entries(state.forecast).splice(0, 4).map(entry => ({\n        ...entry[1][Math.floor(moment().hour() / 3)] // Current hour divided by 3 will give the index of the current hour's forecast\n      }));\n    },\n\n    setIsForecastLoading: (state, action) => {\n      state.isForecastLoading = action.payload;\n    }\n  }\n});\nexport const fetchForecast = () => dispatch => {\n  try {\n    dispatch(setIsForecastLoading(true));\n    navigator.geolocation.getCurrentPosition(async position => {\n      const lat = position.coords.latitude;\n      const lon = position.coords.longitude;\n      const units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n      const response = await forecastService().getForecast({\n        lat,\n        lon,\n        units\n      });\n      dispatch(setIsForecastLoading(false));\n      dispatch(setForecast(response));\n    });\n  } catch (e) {\n    dispatch(setIsForecastLoading(false));\n  }\n};\nexport const {\n  setForecast,\n  setCurrentWeathers,\n  setIsForecastLoading\n} = forecastSlice.actions;\nexport const forecastReducer = forecastSlice.reducer;","map":{"version":3,"names":["createSlice","forecastService","convertToMonthDay","parseForecastObject","STANDARD_UNIT","WEATHER_METRIC_KEY","moment","initialState","forecast","currentWeathers","isForecastLoading","undefined","forecastSlice","name","reducers","setForecast","state","action","_action$payload","payload","list","reduce","acc","current","key","dt_txt","weatherObj","push","setCurrentWeathers","Object","entries","splice","map","entry","Math","floor","hour","setIsForecastLoading","fetchForecast","dispatch","navigator","geolocation","getCurrentPosition","position","lat","coords","latitude","lon","longitude","units","localStorage","getItem","response","getForecast","e","actions","forecastReducer","reducer"],"sources":["/Users/maistor_dany/Projects/weather-app/src/store/forecast/forecast.slice.ts"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\nimport { AppDispatch } from \"../index\";\nimport { forecastService } from \"../../api\";\nimport { HourlyForecastDisplay } from \"../types\";\nimport { convertToMonthDay, parseForecastObject } from \"../../utils\";\nimport { STANDARD_UNIT, WEATHER_METRIC_KEY } from \"../../common/constants\";\nimport { ForecastData } from \"../../api/types\";\nimport moment from \"moment\";\n\ntype ForecastState = {\n  forecast: { [key: string]: HourlyForecastDisplay[] };\n  currentWeathers: HourlyForecastDisplay[];\n  isForecastLoading?: boolean;\n};\n\nconst initialState: ForecastState = {\n  forecast: {},\n  currentWeathers: [],\n  isForecastLoading: undefined,\n};\n\nexport const forecastSlice = createSlice({\n  name: \"forecast\",\n  initialState,\n  reducers: {\n    setForecast: (state, action) => {\n      state.forecast = action.payload?.list.reduce(\n        (\n          acc: { [key: string]: HourlyForecastDisplay[] },\n          current: ForecastData,\n        ) => {\n          const key = convertToMonthDay(current.dt_txt);\n          const weatherObj = parseForecastObject(current);\n\n          if (!acc[key]) {\n            acc[key] = [weatherObj];\n\n            return acc;\n          }\n\n          acc[key].push(weatherObj);\n\n          return acc;\n        },\n        {},\n      );\n    },\n    setCurrentWeathers: (state) => {\n      state.currentWeathers = Object.entries(state.forecast)\n        .splice(0, 4)\n        .map((entry: [string, any]) => ({\n          ...entry[1][Math.floor(moment().hour() / 3)], // Current hour divided by 3 will give the index of the current hour's forecast\n        }));\n    },\n    setIsForecastLoading: (state, action) => {\n      state.isForecastLoading = action.payload;\n    },\n  },\n});\n\nexport const fetchForecast = () => (dispatch: AppDispatch) => {\n  try {\n    dispatch(setIsForecastLoading(true));\n    navigator.geolocation.getCurrentPosition(async (position) => {\n      const lat = position.coords.latitude;\n      const lon = position.coords.longitude;\n\n      const units = localStorage.getItem(WEATHER_METRIC_KEY) || STANDARD_UNIT;\n      const response = await forecastService().getForecast({\n        lat,\n        lon,\n        units,\n      });\n\n      dispatch(setIsForecastLoading(false));\n      dispatch(setForecast(response));\n    });\n  } catch (e) {\n    dispatch(setIsForecastLoading(false));\n  }\n};\n\nexport const { setForecast, setCurrentWeathers, setIsForecastLoading } =\n  forecastSlice.actions;\n\nexport const forecastReducer = forecastSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}